<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
  <style type="text/css">
    * { box-sizing: border-box; padding: 0; margin: 0; user-select: none; touch-action: none; }
  </style>
</head>
<body>
  <div>
    <select name="inputType">
      <option value="wasd">WASD</option>
      <option value="arrow">방향키</option>
    </select>
    , shape: 
    <select name="shape">
      <option value="rect">사각형</option>
      <option value="triangle">삼각형</option>
      <option value="circle">원형</option>
      <option value="image">이미지</option>
    </select>
    , color: 
    <select name="color">
      <option value="red">red</option>
      <option value="blue">blue</option>
      <option value="green">green</option>
    </select>
    <button id="addPlayer">+</button>
    <button id="stop">stop</button>
    <button id="reset">reset</button>
    <button id="destroy">destroy</button>
  </div>
  <script type="text/javascript">
    function StageUtil(){}
    StageUtil = (()=>{
      return {
        // 두 점 사이의 거리
        getDistance(x1, y1, x2, y2){
          // 거리의 제곱 = 밑변의 제곱 + 높이의 제곱
          // 거리 = 루트(밑변의 제곱 + 높이의 제곱)
          return Math.sqrt(Math.pow((x2 - x1),2)+Math.pow((y2 - y1),2));
        },
        // 두 점 사이의 각도
        getAngle(x1, y1, x2, y2, rotate){
          return (Math.atan2((y2 - y1), (x2 - x1)) * (180/Math.PI)) + (rotate||0);
        },
        // 특정 각도로 특정 길이만큼 이동했을 때 좌표
        getMoveDistPos(dist, angle, x1, y1){
          const distX = (dist * Math.cos(angle*(Math.PI/180)));
          const distY = (dist * Math.sin(angle*(Math.PI/180)));
          return {
            x: x1 + distX,
            y: y1 + distY,
            distX: distX,
            distY: distY,
            left: distX < 0,
            right: distX > 0,
            up: distY < 0,
            down: distY > 0,
          }
        },
        // 회전시키기
        setRotate(rotate, width, x1, y1, x2, y2){
          const angle = StageUtil.getAngle(x1, y1, x2, y2, rotate); // 각도
          const dist = StageUtil.getDistance(x1, y1, x1+(width/2), y1+(width/2)); // 거리
          return {
            x: x1 + (dist * Math.cos((angle * Math.PI/180))),
            y: y1 + (dist * Math.sin((angle * Math.PI/180))),
          }
        }
      }
    })();
  </script>
  <script type="text/javascript">
    function Player(canvas, settings){
      // Player Configurations
      const config = {
        _id: null,
        name: "Unknown",
        health: 100,
        pos: {
          x: canvas.width/2,
          y: canvas.height/2
        },
        shape: {
          type: "circle",
          color: "#000000",
          size: {
            width: 30,
            height: 30,
          }
        },
        inputType: "wasd" // wasd: Default, arrow
      };
      if( settings ){
        Object.keys(settings).forEach((key)=>{
          const value = settings[key];
          config[key] = (
            !(value instanceof Array) && value instanceof Object
            ? Object.assign(config[key]||{}, value)
            : settings[key]
          );
        });
      }

      // Player ID
      this.getConfig = (k)=>(config[k]);
      this.setConfig = (k,v)=>(config[k]=v);
      this.getId = ()=>(config._id);
      this.getName = ()=>(config.name);

      // Instance
      const insts = {
        root: document.querySelector(config.rootElement)||document.body,
        canvas: canvas,
        ctx: (canvas ? canvas.getContext("2d") : null),
      }
      this.getInst = (k)=>(insts[k]);
      this.setInst = (k,v)=>(insts[k]=v);
      this.getRoot = (k)=>(insts.root);
      this.getCanvas = ()=>(insts.canvas);
      this.getCtx = ()=>(insts.ctx);
      this.setCtx = (v)=>(insts.ctx=v);

      // Status
      const status = {
        jumpping: false
      }
      this.getStatus = (k)=>(status[k]);
      this.setStatus = (k,v)=>(status[k]=v);

      // Shape
      const shape = {
        type: "circle", // rect, circle, triangle
        color: "#ffffff" , // black
        size: {
          width: 30,
          height: 30,
          radius: 15,
        }
      }
      Object.assign(shape, config.shape);
      shape.size.radius = (shape.size.width/2);

      this.getShape = ()=>(shape.type);
      this.setShape = (v)=>(shape.type=v);
      this.getSize = ()=>(shape.size);
      this.setSize = (width,height)=>(shape.size = { width, height });
      this.getWidth = ()=>(shape.size.width);
      this.setWidth = (width)=>{
        shape.size.width = width;
        shape.size.radius = (width/2);
      };
      this.getHeight = ()=>(shape.size.height);
      this.setHeight = (height)=>(shape.size.height = height);
      this.getRadius = ()=>(shape.size.radius);
      this.setRadius = (v)=>(shape.size.radius=v);
      this.getColor = ()=>(shape.color);
      this.setColor = (v)=>(shape.color = v);

      // Position: Player
      const move = {
        speed: 5,
        pos: {
          x: 0, y: 0
        }
      }
      Object.assign(move.pos, config.pos);

      this.getMovePos = ()=>(move.pos);
      this.setMovePos = (x,y)=>(Object.assign(move.pos,{x,y}));
      this.getMovePosX = ()=>(move.pos.x);
      this.setMovePosX = (x)=>(move.pos.x = x);
      this.getMovePosY = ()=>(move.pos.y);
      this.setMovePosY = (y)=>(move.pos.y = y);
      this.getMoveSpeed = ()=>(move.speed);
      this.setMoveSpeed = (v)=>(move.speed=v);

      // Positions: Aim
      const aim = {
        size: 3,
        dist: {
          now: shape.size.width*2,
          min: 10,
          max: 200
        },
        pos: {
          x: 100, y: 100,
        }
      }
      this.getAimPos = ()=>(aim.pos);
      this.setAimPos = (x,y)=>(Object.assign(aim.pos,{x,y}));
      this.getAimPosX = ()=>(aim.pos.x);
      this.setAimPosX = (x)=>(aim.pos.x=x);
      this.getAimPosY = ()=>(aim.pos.y);
      this.setAimPosY = (y)=>(aim.pos.y=y);
      this.getAimDist = ()=>(aim.dist.now);
      this.setAimDist = (v)=>(aim.dist.now=v);
      this.getAimSize = ()=>(aim.size);
      this.setAimSize = (v)=>(aim.size=v);
      this.getAimDistMin = ()=>(aim.dist.min);
      this.getAimDistMax = ()=>(aim.dist.max);

      // Initialize
      return this.init();
    }
    Player.prototype = (()=>{
      const _init = (self)=>{
        /**
         * 실시간으로 움직이는 정보를 받을 수 있도록 Socket 처리
         * 1) Socket Connection
         * 2) Socket Event Emit
         * 3) Socket Event Receiver
         */

        // Player 그리기
        _draw(self);
      }
      
      // 원형 그리기
      const _drawCircle = (self, x, y, radius)=>{
        const ctx = self.getCtx();
        const color = self.getColor();
        const aimX = self.getAimPosX();
        const aimY = self.getAimPosY();
        const zeroX = x + radius;
        const zeroY = y + radius;

        const angle = StageUtil.getAngle(zeroX, zeroY, aimX, aimY);

        ctx.beginPath();
        //ctx.arc(x + radius, y + radius, radius, 0,  Math.PI*2, 0);
        ctx.arc(x + radius, y + radius, radius, angle, 360, 0);
        ctx.fillStyle = color;
        ctx.fill();
        ctx.closePath();
      }
      // 사각형 그리기
      const _drawRectangle = (self, x, y, width, height)=>{
        const ctx = self.getCtx();
        const color = self.getColor();
        const aimX = self.getAimPosX();
        const aimY = self.getAimPosY();
        const zeroX = x + (width / 2);
        const zeroY = y + (width / 2);

        const p1 = StageUtil.setRotate(0, width, zeroX, zeroY, aimX, aimY);
        const p2 = StageUtil.setRotate(90, width, zeroX, zeroY, aimX, aimY);
        const p3 = StageUtil.setRotate(180, width, zeroX, zeroY, aimX, aimY);
        const p4 = StageUtil.setRotate(270, width, zeroX, zeroY, aimX, aimY);

        ctx.beginPath();
        ctx.moveTo(p1.x, p1.y);
        ctx.lineTo(p2.x, p2.y);
        ctx.lineTo(p3.x, p3.y);
        ctx.lineTo(p4.x, p4.y);
        ctx.fillStyle = color;
        ctx.fill();
        ctx.closePath();

        ctx.beginPath();
        ctx.moveTo(p1.x, p1.y);
        ctx.arc(p1.x, p1.y, 2, 0, Math.PI*2, 0);
        ctx.fillStyle = "blue";
        ctx.fill();
        ctx.closePath();
      }
      // 이미지 그리기
      const _drawImage = (self, x, y, width, height)=>{
        const ctx = self.getCtx();
        const color = self.getColor();

        const playerImage = new Image();
        playerImage.src = context+"/images/player.png";
        playerImage.addEventListener("load", (e)=>{
          ctx.drawImage(playerImage, x, y, width, height);
        });
      }
      // 삼각형 그리기
      const _drawTriangle = (self, x, y, width, height)=>{
        const ctx = self.getCtx();
        const color = self.getColor();
        const aimX = self.getAimPosX();
        const aimY = self.getAimPosY();
        const zeroX = x + (width / 2);
        const zeroY = y + (width / 2);

        const p1 = StageUtil.setRotate(0, width, zeroX, zeroY, aimX, aimY);
        const p2 = StageUtil.setRotate(140, width, zeroX, zeroY, aimX, aimY);
        const p3 = StageUtil.setRotate(-140, width, zeroX, zeroY, aimX, aimY);

        ctx.beginPath();
        ctx.moveTo(p1.x, p1.y);
        ctx.lineTo(p2.x, p2.y);
        ctx.lineTo(p3.x, p3.y);
        ctx.fillStyle = color;
        ctx.fill();
        ctx.closePath();

        ctx.beginPath();
        ctx.moveTo(p1.x, p1.y);
        ctx.arc(p1.x, p1.y, 2, 0, Math.PI*2, 0);
        ctx.fillStyle = "blue";
        ctx.fill();
        ctx.closePath();
      }
      // 텍스트 그리기
      const _drawText = (self, text, x, y)=>{
        const ctx = self.getCtx();
        const color = self.getColor();

        ctx.beginPath();
        ctx.font = "15px Arial";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.direction = "inherit";
        ctx.fillStyle = color;
        ctx.fillText(text, x, y);
        ctx.closePath();
      }
      // Player 그리기
      const _drawPlayer = (self)=>{
        const ctx = self.getCtx();

        const name = self.getName()||"Unknown";
        const shape = self.getShape();

        const width = self.getWidth();
        const height = self.getHeight();
        const radius = self.getRadius();
        const movePos = self.getMovePos();

        if( shape === "circle" ){
           // 원형
          _drawCircle(self, movePos.x, movePos.y, radius);

        } else if ( shape === "triangle"){
           // 삼각형
          _drawTriangle(self, movePos.x, movePos.y, width, height);

        } else if ( shape === "rect"){
           // 사각형
          _drawRectangle(self, movePos.x, movePos.y, width, height);

        } else if ( shape === "image"){
           // 이미지
          _drawImage(self, movePos.x, movePos.y, width, height);

        }
        // 이름 표시
        _drawText(self, name, movePos.x + radius, movePos.y - 10);
      }

      const _drawAiming = (self)=>{
        const ctx = self.getCtx();
        const width = self.getWidth();
        const height = self.getHeight();
        const radius = self.getRadius();
        const movePos = self.getMovePos();
        const zeroX = movePos.x + radius;
        const zeroY = movePos.y + radius;

        const aimSize = self.getAimSize();
        const aimPos = self.getAimPos();
        const aimDist = self.getAimDist();
        const aimAngle = StageUtil.getAngle(zeroX, zeroY, aimPos.x, aimPos.y);

        const crntAimDist = StageUtil.getDistance(zeroX, zeroY, aimPos.x, aimPos.y);
        const crntAimPos = StageUtil.getMoveDistPos(aimDist, aimAngle, zeroX, zeroY);

        // Aiming 표시
        ctx.beginPath();
        ctx.fillStyle = "blue";
        ctx.setLineDash([]);
        ctx.moveTo(crntAimPos.x, crntAimPos.y);
        ctx.arc(crntAimPos.x, crntAimPos.y, aimSize, 0, Math.PI*2, 0);
        ctx.fill();
        ctx.closePath();

        // Aim 범위 표시
        ctx.beginPath();
        ctx.setLineDash([width/3,width]);
        ctx.arc(zeroX, zeroY, aimDist, 0, Math.PI*2, 0);
        ctx.strokeStyle = "red";
        ctx.stroke();
        ctx.setLineDash([]);
        ctx.closePath();

        // Aim Line 표시
        ctx.beginPath();
        ctx.strokeStyle = "lightgrey";
        ctx.setLineDash([5,5]);
        ctx.moveTo(zeroX, zeroY);
        ctx.arc(zeroX, zeroY, 1, 0, Math.PI*2, 0);
        ctx.lineTo(crntAimPos.x, crntAimPos.y);
        ctx.stroke();
        ctx.setLineDash([]);
        ctx.closePath();
      }

      const _drawGuide = (self)=>{
        const ctx = self.getCtx();
        
        const width = self.getWidth();
        const height = self.getHeight();
        const R = self.getRadius();
        const pR = 3;

        const moveX = self.getMovePosX();
        const moveY = self.getMovePosY();
        const aimX = self.getAimPosX();
        const aimY = self.getAimPosY();

        // 십자모양 출력
        ctx.beginPath();
        ctx.strokeStyle = "red";
        ctx.moveTo(moveX, moveY + R);
        ctx.lineTo(moveX + width, moveY + R);  // 가로선
        ctx.moveTo(moveX + R, moveY);
        ctx.lineTo(moveX + R, moveY + height); // 세로선
        ctx.stroke();
        ctx.closePath();
      }

      const _draw = (self)=>{
        _drawPlayer(self); // Player 그리기
        //_drawAiming(self); // Aiming 그리기
        //_drawGuide(self); // Guide 그리기
      }

      return {
        init(){
          _init(this);
          return this;
        },
        draw(){
          _draw(this);
          return this;
        },
      }
    })();
  </script>
  <script type="text/javascript">
    function StageManager(root, settings){
      const config = {
        root: (root||document.body),
        size: {
          width: 500,
          height: 500,
        }
      }
      if( settings ){
        Object.keys(settings).forEach((key)=>{
          const value = settings[key];
          config[key] = (
            !(value instanceof Array) && value instanceof Object
            ? Object.assign(config[key]||{}, value)
            : settings[key]
          );
        });
      }

      // Configurations
      this.getConfig = (k)=>(config[k]);
      this.setConfig = (k,v)=>(config[k]=v);

      // Instance
      const insts = {
        root: config.root,
        canvas: null
      }
      this.getInst = (k)=>(insts[k]);
      this.setInst = (k,v)=>(insts[k]=v);
      this.getRoot = ()=>(insts.root);
      this.getCanvas = ()=>(insts.canvas);
      this.setCanvas = (v)=>(insts.canvas=v);
      this.getCtx = ()=>(insts.ctx);
      this.setCtx = (v)=>(insts.ctx=v);

      // State
      const state = {
        players: 0,
        drawing: false,
      }
      this.getState = (k)=>(state[k]);
      this.setState = (k,v)=>(state[k] = v);

      // Players
      const player = {
        me: null,
        others: [],
      }
      this.getPlayer = ()=>(player.me);
      this.setPlayer = (v)=>(player.me=v);
      this.getPlayers = ()=>(player.others);
      this.addPlayer = (v)=>{
        player.others.push(v);
        state.players = player.others.length;
      };

      // Shape
      const shape = {
        size: {
          width: 500,
          height: 500,
        }
      }
      Object.assign(shape.size, config.size);
      this.getSize = ()=>(shape.size);
      this.setSize = (v)=>(Object.assign(shape.size, v));
      this.getWidth = ()=>(shape.size.width);
      this.getHeight = ()=>(shape.size.height);

      // Positions: pointer
      const pointer = {
        pressed: false,
        pos: {
          x: 0,
          y: 0
        }
      }
      this.getPointerPos = ()=>(pointer.pos);
      this.setPointerPos = (x,y)=>(Object.assign(pointer.pos,{x,y}));
      this.getPointerPosX = ()=>(pointer.pos.x);
      this.setPointerX = (x)=>(pointer.pos.x=x);
      this.getPointerPosY = ()=>(pointer.pos.y);
      this.setPointerY = (y)=>(pointer.pos.y=y);
      this.pointerDown = ()=>(pointer.pressed=true);
      this.pointerUp = ()=>(pointer.pressed=false);
      this.pointerPressed = ()=>(pointer.pressed);

      // Keyboard Pressed
      const pressKeys = {};
      this.keyboardPressed = (k)=>( k ? k in pressKeys : Object.keys(pressKeys).length > 0 );
      this.keyboardDown = (k)=>(pressKeys[k]=true);
      this.keyboardUp = (k)=>(delete pressKeys[k]);
      
      // Keyboard Codes
      this.KEYCODE = {
        "ARROW_LEFT": 37,
        "ARROW_UP": 38,
        "ARROW_RIGHT": 39,
        "ARROW_DOWN": 40,
        "A": 65,
        "W": 87,
        "D": 68,
        "S": 83,
      }
      this.KEYCODE_ARROW = {
        "LEFT": this.KEYCODE.ARROW_LEFT,
        "UP": this.KEYCODE.ARROW_UP,
        "RIGHT": this.KEYCODE.ARROW_RIGHT,
        "DOWN": this.KEYCODE.ARROW_DOWN,
      }
      this.KEYCODE_WASD = {
        "LEFT": this.KEYCODE.A,
        "UP": this.KEYCODE.W,
        "RIGHT": this.KEYCODE.D,
        "DOWN": this.KEYCODE.S,
      }
      this.getKeyCode = (k)=>(
        (k||"wasd").toLowerCase() === "wasd"
        ? this.KEYCODE_WASD
        : this.KEYCODE_ARROW 
      );
    }
    StageManager.prototype = (()=>{
      const _init = (self, settings) => {
        // Draw instance
        _initCanavs(self);
        _initPlayer(self);
        // Binding Events
        _bindEvent(self);
        // Run
        _start(self);
      }

      /**
       * 이벤트 바인딩
       * - keyDown: 키 입력 중
       * - keyUp: 키 입력 완료
       * - mousedown, touchstart: 포인터 입력 중
       * - mouseup, touchend: 포인터 입력 완료
       * - mousemove, touchemove: 포인터 이동
       */
      const _bindEvent = (self)=>{
        self.getRoot().addEventListener("keydown", (e)=>{ self.keyboardDown(e.keyCode); });
        self.getRoot().addEventListener("keyup", (e)=>{ self.keyboardUp(e.keyCode); });
        
        self.getRoot().addEventListener("mousedown", (e)=>{
          self.setPointerPos(e.offsetX, e.offsetY);
          self.pointerDown();
        });
        self.getRoot().addEventListener("mouseup", (e)=>{ self.pointerUp(); });
        self.getRoot().addEventListener("mousemove", (e)=>{ self.setPointerPos(e.offsetX, e.offsetY); });

        self.getRoot().addEventListener("touchstart", (e)=>{ 
          self.setPointerPos(
            e.touches[0].clientX - self.getCanvas().offsetLeft,
            e.touches[0].clientY - self.getCanvas().offsetTop
          );
          self.pointerDown();
        });
        self.getRoot().addEventListener("touchend", (e)=>{ self.pointerUp(); });
        self.getRoot().addEventListener("touchmove", (e)=>{ 
          self.setPointerPos(
            e.touches[0].clientX - self.getCanvas().offsetLeft,
            e.touches[0].clientY - self.getCanvas().offsetTop
          );
        });
      }
      
      // Canvas 생성
      const _initCanavs = (self)=>{
        const root = self.getRoot();
        const canvasId = "canvas-playground";
        let canvas = root.querySelector("canvas#"+canvasId);
        if( !canvas ){
          canvas = root.appendChild(document.createElement("canvas"));
        }
        canvas.id = "canvas-playground";
        canvas.width = self.getWidth();
        canvas.height = self.getHeight();

        self.setCanvas(canvas);
        self.setCtx(canvas.getContext("2d"));
      }

      // Main Player 생성
      const _initPlayer = (self)=>{
        const playerName = "me";
        const inputType = "wasd";
        const player = new Player(
          self.getCanvas(),
          {
            name: playerName,
            inputType: inputType, 
            shape: {
              type: "triangle",
              color: "grey",
              size: {
                width: 20,
                height: 20,
              }
            },
            pos: {
              x: self.getWidth()/2,
              y: self.getHeight()/2,
            },
          }
        );
        stage.setPlayer(player);
      }
      
      // Player 위치 갱신
      const _updatePos = (self, player)=>{
        // Canvas 정보
        const canvas = self.getCanvas();
        const pointerPos = self.getPointerPos();

        // Player 정보
        const playerSize = player.getSize();
        const playerInput = player.getConfig("inputType");
        const playerPos = player.getMovePos();
        const playerAimPos = player.getAimPos();
        let playerSpeed = player.getMoveSpeed();

        // 좌표값
        const KEYCODE = self.getKeyCode(playerInput);
        const limitX = [0, canvas.width - playerSize.width];
        const limitY = [0, canvas.height - playerSize.height];
        let moveX = playerPos.x;
        let moveY = playerPos.y;
        
        // 입력 키에 따른 좌표값 설정
        if( self.keyboardPressed(KEYCODE.RIGHT) ){ moveX += playerSpeed; }
        if( self.keyboardPressed(KEYCODE.LEFT) ){ moveX -= playerSpeed; }
        if( self.keyboardPressed(KEYCODE.DOWN) ){ moveY += playerSpeed; }
        if( self.keyboardPressed(KEYCODE.UP) ){ moveY -= playerSpeed; }

        // 좌표 최소/최대 설정
        if( moveX < limitX[0] ){ moveX = limitX[0]; }
        if( moveY < limitY[0] ){ moveY = limitY[0]; }
        if( moveX > limitX[1] ){ moveX = limitX[1]; }
        if( moveY > limitY[1] ){ moveY = limitY[1]; }

        // 좌표로 설정
        player.setMovePos(moveX, moveY);
      }

      // Player Pointer Pos
      const _followPointer = (self, player)=>{
        // Canvas 정보
        const canvas = self.getCanvas();
        const pointerPos = self.getPointerPos();

        // Player 정보
        const playerSize = player.getSize();
        const playerInput = player.getConfig("inputType");
        const playerPos = player.getMovePos();
        const playerAimPos = player.getAimPos();
        let playerSpeed = player.getMoveSpeed();

        // 좌표값
        const limitX = [0, canvas.width - playerSize.width];
        const limitY = [0, canvas.height - playerSize.height];
        let moveX = playerPos.x;
        let moveY = playerPos.y;

        // 마우스,터치 입력 상태에 따른 좌표값 설정
        if( self.pointerPressed() ){
          const aimAngle = StageUtil.getAngle(moveX, moveY, playerAimPos.x, playerAimPos.y);
          const aimDistPos = StageUtil.getMoveDistPos(playerSpeed, aimAngle, moveX, moveY);

          if(( aimDistPos.left && playerAimPos.x - playerSpeed > pointerPos.x )|| // 왼쪽, aim > pointer
             ( aimDistPos.right && playerAimPos.x + playerSpeed < pointerPos.x ))  // 오른쪽, aim < pointer
            {
            moveX = aimDistPos.x;
          }
          if(( aimDistPos.up && playerAimPos.y - playerSpeed > pointerPos.y )|| // 상단, aim < pointer
             ( aimDistPos.down && playerAimPos.y + playerSpeed < pointerPos.y ))  // 하단, aim > pointer
            {
            moveY = aimDistPos.y;
          }
        }

        // 좌표 최소/최대 설정
        if( moveX < limitX[0] ){ moveX = limitX[0]; }
        if( moveY < limitY[0] ){ moveY = limitY[0]; }
        if( moveX > limitX[1] ){ moveX = limitX[1]; }
        if( moveY > limitY[1] ){ moveY = limitY[1]; }

        // 좌표로 설정
        player.setMovePos(moveX, moveY);
      }

      // Player Pointer Pos
      const _followPlayer = (self, player)=>{
        // Player 정보
        const follow = player.getConfig("follow");
        const playerSize = player.getSize();
        const playerInput = player.getConfig("inputType");
        const playerPos = player.getMovePos();
        const playerAimPos = follow.getMovePos();
        let playerSpeed = player.getMoveSpeed();
        
        // Canvas 정보
        const canvas = self.getCanvas();

        // 좌표값
        const limitX = [0, canvas.width - playerSize.width];
        const limitY = [0, canvas.height - playerSize.height];
        let moveX = playerPos.x;
        let moveY = playerPos.y;

        // 마우스,터치 입력 상태에 따른 좌표값 설정
        const aimAngle = StageUtil.getAngle(moveX, moveY, playerAimPos.x, playerAimPos.y);
        const aimDistPos = StageUtil.getMoveDistPos(playerSpeed, aimAngle, moveX, moveY);

        moveX = aimDistPos.x;
        moveY = aimDistPos.y;

        // 좌표로 설정
        player.setMovePos(moveX, moveY);
        player.setAimPos(playerAimPos.x, playerAimPos.y);
      }

      // Player Aim 갱신
      const _updateAim = (self, player)=>{
        // Canvas 정보
        const pointerPos = self.getPointerPos();
        
        // Player 정보
        const playerRadius = player.getRadius();
        const playerPos = {
          x: player.getMovePosX() + playerRadius,
          y: player.getMovePosY() + playerRadius,
        };

        // Player Aim 정보
        const aimDist = player.getAimDist();
        const aimAngle = StageUtil.getAngle(playerPos.x, playerPos.y, pointerPos.x, pointerPos.y);
        const aimX = playerPos.x + (aimDist * Math.cos(aimAngle*(Math.PI/180)));
        const aimY = playerPos.y + (aimDist * Math.sin(aimAngle*(Math.PI/180)));
        
        // 좌표로 설정
        player.setAimPos(aimX, aimY);
      }

      // Stage 그리기
      const _drawStage = (self)=>{
        const ctx = self.getCtx();
        const size = self.getSize();
        const pointer = self.getPointerPos();

        // Background 그리기
        ctx.beginPath();
        ctx.strokeStyle = "#000000";
        ctx.rect(0, 0, size.width, size.height);
        ctx.stroke();
        ctx.closePath();
        
        // Pointer 그리기
        ctx.beginPath();
        ctx.fillStyle = "red";
        ctx.setLineDash([]);
        ctx.moveTo(pointer.x, pointer.y);
        ctx.arc(pointer.x, pointer.y, 5, 0, Math.PI*2, 0);
        ctx.fill();
        ctx.closePath();
      }

      // Player 그리기
      const _drawPlayers = (self)=>{
        const mainPlayer = self.getPlayer();
        mainPlayer.draw();

        self.getPlayers().forEach((player)=>{
          
          _followPlayer(self, player);

          // Player 그리기
          player.draw();
        });
      }

      // Canvas 그리기 이벤트
      const _draw = (self)=>{
        // Canvas 그리기 서브 이벤트
        function drawer(){
          _clear(self); // Canvas 초기화
          
          const player = self.getPlayer();
          _updatePos(self, player); // Player 위치 갱신
          _updateAim(self, player); // Player Aim 갱신
          _followPointer(self, player); // Player Aim 갱신

          _drawStage(self); // Stage 그리기
          _drawPlayers(self); // Player 그리기

          // 현재 상태 저장
          self.setState("drawing", requestAnimationFrame(drawer));
        }
        // 그리는 중인 경우 중단
        cancelAnimationFrame(self.getState("drawing"));
        self.setState("drawing", null);
        
        // 그리기 시작
        drawer();
      }

      // Canvas 초기화 이벤트
      const _clear = (self)=>{
        self.getCtx().clearRect(0,0,self.getWidth(),self.getHeight());
      }

      // 시작 이벤트
      const _start = (self)=>{
        const isDrawing = self.getState("drawing");
        if( !isDrawing ){
          _draw(self);
        }
      }

      // 중단 이벤트
      const _stop = async (self)=>{
        const drawing = self.getState("drawing");
        if( drawing ){
          await cancelAnimationFrame(drawing);
          self.setState("drawing", null);
        }
      }

      // 종료 이벤트
      const _destroy = async (self)=>{
        await _stop(self);
        await _clear(self);
        /**
         *  @TODO: 플레이어 데이터 삭제
        const players = self.getPlayers();
        players.forEach((player)=>{
          player.destroy();
        });
        */
      }
      
      return {
        init(settings){
          _init(this, settings);
        },
        draw(){
          _draw(this);
        },
        start(){
          _start(this);
        },
        stop(){
          _stop(this);
        },
        destroy(){
          _destroy(this);
        }
      }
    })();

    stage = new StageManager(
      document.body, 
      { 
        size: { 
          width: (window.screen.width/5)*4, 
          height: (window.screen.height/5)*3
        }
      }
    );
    stage.init();
  </script>
  <script>

    const context = "/my-three-server/public";

    setInterval(addPlayer, Math.random()*1000);

    function addPlayer(){
      const playerName = "NPC-"+(stage.getPlayers().length+1);
      const inputType = document.querySelector("[name=inputType]").value;
      const player = stage.getPlayer();

      const randToggle = parseInt(Math.random()*1.5);
      const randPos = {
        x: ( randToggle === 0 ? Math.random()*stage.getWidth() : stage.getWidth() ),
        y: ( randToggle === 0 ? stage.getHeight() : Math.random()*stage.getHeight() ),
      }
      const NPC = new Player(
        stage.getCanvas(),
        {
          name: playerName,
          inputType: inputType, 
          pos: {
            x: randPos.x,
            y: randPos.y,
          },
          follow: player,
          shape: {
            type: document.querySelector("[name=shape]").value,
            color: document.querySelector("[name=color]").value,
            size: {
              width: 10,
              height: 10,
            },
            aim: {
              
            }
          },
        }
      );
      NPC.setMoveSpeed(Math.random()*3+1);

      stage.addPlayer(NPC);
    }
  </script>
  <script type="text/javascript">
    document.querySelector("#addPlayer").addEventListener("click", (e)=>{
      e.preventDefault();
      addPlayer();
      return false;
    });
    document.body.addEventListener("keydown", (e)=>{
      if( e.keyCode === 32 /* SpaceBar */ ){
        const triggerElement = document.querySelector("#addPlayer");
        const triggerEventType = "click";
        if( typeof document.createEvent === "function" ){
          // IE9+ and other modern browsers
          const triggerEvent = document.createEvent('HTMLEvents');
          triggerEvent.initEvent(triggerEventType, false, true);
          triggerElement.dispatchEvent(triggerEvent); 
        } else {
          // IE8
          const triggerEvent = document.createEventObject();
          triggerEvent.eventType = triggerEventType;
          triggerElement.fireEvent('on' + triggerEvent.eventType, e);
        }
      }
    });
    document.querySelector("#stop").addEventListener("click", (e)=>{
      e.preventDefault();
      stage.stop();
    });
    document.querySelector("#reset").addEventListener("click", (e)=>{
      e.preventDefault();
      stage.init();
    });
    document.querySelector("#destroy").addEventListener("click", (e)=>{
      e.preventDefault();
      stage.destroy();
    });
  </script>
</body>
</html>
